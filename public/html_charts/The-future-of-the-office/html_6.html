<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Driven Architectural Design Process</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
            display: flex;
            justify-content: center;
        }
        
        .visualization-container {
            width: 1100px; /* Increased width to accommodate all content */
            background-color: white;
            padding: 30px;
            border-radius: 8px;
        }
        
        .title {
            font-size: 18pt;
            font-weight: bold;
            color: #002D5A;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 14pt;
            color: #4A4A4A;
            text-align: center;
            margin-bottom: 30px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .process-flow {
            border: 1px solid #8C50FF;
            border-radius: 8px;
            padding: 20px;
            position: relative;
        }
        
        .stage-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .stage {
            width: 18%;
            background-color: white;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
        }
        
        .stage-header {
            background-color: #f0e6ff;
            padding: 10px;
            text-align: center;
        }
        
        .stage-title {
            font-size: 14pt;
            font-weight: bold;
            color: #8C50FF;
            margin: 0;
        }
        
        .stage-description {
            padding: 10px;
            font-size: 11pt;
            color: #333;
            height: 80px;
            display: flex;
            align-items: center;
        }
        
        .stage-image {
            height: 140px;
            background-color: #f5f5f5;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        .stage-image svg {
            width: 100%;
            height: 100%;
        }
        
        .key-insight {
            background-color: #f0e6ff;
            border-radius: 6px;
            padding: 15px;
            margin-top: 20px;
            position: relative;
        }
        
        .key-insight:before {
            content: "Key Insight";
            position: absolute;
            top: -10px;
            left: 20px;
            background-color: #8C50FF;
            color: white;
            padding: 2px 10px;
            border-radius: 4px;
            font-size: 12pt;
            font-weight: bold;
        }
        
        .source {
            font-size: 9pt;
            font-style: italic;
            color: #666;
            text-align: right;
            margin-top: 15px;
        }
        
        .highlight {
            font-family: 'Georgia', serif;
            font-size: 16pt;
            color: #8C50FF;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="visualization-container">
        <div class="title">AI-Driven Architectural Design Process for Workplace Concepts</div>
        <div class="subtitle">How generative AI tools transform text prompts into refined space concepts through iterative prompt engineering</div>
        
        <div class="process-flow" id="process-flow">
            <!-- D3.js will render the visualization here -->
        </div>
        
        <div class="key-insight">
            After <span class="highlight">12</span> progressively specific prompts, the system produced high-quality designs with accurate brand representation, validating AI as an effective design support tool
        </div>
        
        <div class="source">
            Source: Adapted from Ekici & Çelik research on AI-driven architectural concept generation (2025)
        </div>
    </div>

    <script>
        // Data for the stages
        const stageData = [
            {
                id: 1,
                title: "Initial Prompt",
                description: "Basic text description of desired office space (e.g., \"modern office with green elements for a tech company\")",
                imageType: "sketch"
            },
            {
                id: 2,
                title: "First Generation Concepts",
                description: "AI produces initial concepts with varying quality and alignment to brand",
                imageType: "rough"
            },
            {
                id: 3,
                title: "Prompt Refinement",
                description: "Designer adds specific details to prompt (e.g., \"incorporate seagull logo, sustainable materials, and R&D zone\")",
                imageType: "text"
            },
            {
                id: 4,
                title: "Refined Concepts",
                description: "AI generates more targeted designs incorporating specific brand and functional elements",
                imageType: "improved"
            },
            {
                id: 5,
                title: "Final Concept Development",
                description: "Designer selects and further refines promising AI-generated concepts for client presentation",
                imageType: "final"
            }
        ];

        // Create the flow diagram
        const width = 1060; // Increased width to accommodate all content
        const height = 400;

        const svg = d3.select("#process-flow")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", `0 0 ${width} ${height}`)
            .attr("style", "max-width: 100%; height: auto;");

        // Create stage containers
        const stageWidth = 190; // Increased width to prevent truncation
        const stageHeight = 280;
        const stageSpacing = (width - (stageWidth * 5)) / 4;
        
        const stages = svg.selectAll(".stage-group")
            .data(stageData)
            .enter()
            .append("g")
            .attr("class", "stage-group")
            .attr("transform", (d, i) => `translate(${i * (stageWidth + stageSpacing)}, 20)`);

        // Create stage boxes
        stages.append("rect")
            .attr("width", stageWidth)
            .attr("height", stageHeight)
            .attr("rx", 6)
            .attr("ry", 6)
            .attr("fill", "white")
            .attr("stroke", "#ddd")
            .attr("stroke-width", 1);

        // Create stage headers
        stages.append("rect")
            .attr("width", stageWidth)
            .attr("height", 40)
            .attr("rx", 6)
            .attr("ry", 6)
            .attr("fill", "#f0e6ff");

        stages.append("text")
            .attr("x", stageWidth / 2)
            .attr("y", 25)
            .attr("text-anchor", "middle")
            .attr("fill", "#8C50FF")
            .attr("font-weight", "bold")
            .attr("font-size", "14px")
            .text(d => d.title);

        // Create stage descriptions
        stages.append("foreignObject")
            .attr("x", 10)
            .attr("y", 50)
            .attr("width", stageWidth - 20)
            .attr("height", 80)
            .append("xhtml:div")
            .style("font-size", "11px")
            .style("color", "#333")
            .style("overflow", "hidden")
            .html(d => d.description);

        // Create image placeholders with different representations based on stage
        stages.each(function(d) {
            const stage = d3.select(this);
            const imageArea = stage.append("g")
                .attr("transform", `translate(0, 130)`)
                .attr("width", stageWidth)
                .attr("height", 140);
            
            // Background for image area
            imageArea.append("rect")
                .attr("width", stageWidth)
                .attr("height", 140)
                .attr("fill", "#f5f5f5");
                
            // Different image representations based on stage
            switch(d.imageType) {
                case "sketch":
                    // Simple sketch lines for initial prompt
                    imageArea.append("path")
                        .attr("d", `M30,70 Q${stageWidth/2},20 ${stageWidth-30},70`)
                        .attr("stroke", "#8C50FF")
                        .attr("stroke-width", 2)
                        .attr("fill", "none");
                    imageArea.append("rect")
                        .attr("x", stageWidth/2 - 30)
                        .attr("y", 70)
                        .attr("width", 60)
                        .attr("height", 40)
                        .attr("stroke", "#8C50FF")
                        .attr("stroke-width", 2)
                        .attr("fill", "none");
                    break;
                    
                case "rough":
                    // Rough concept visualization
                    for (let i = 0; i < 3; i++) {
                        imageArea.append("rect")
                            .attr("x", 20 + i*(stageWidth-40)/3)
                            .attr("y", 40) // Adjusted vertical position
                            .attr("width", (stageWidth-60)/3)
                            .attr("height", 35)
                            .attr("fill", "#d9c6ff")
                            .attr("stroke", "#8C50FF");
                        
                        imageArea.append("line")
                            .attr("x1", 20 + i*(stageWidth-40)/3)
                            .attr("y1", 90) // Adjusted vertical position
                            .attr("x2", 20 + (i+1)*(stageWidth-40)/3)
                            .attr("y2", 90) // Adjusted vertical position
                            .attr("stroke", "#8C50FF")
                            .attr("stroke-dasharray", "3,3");
                    }
                    break;
                    
                case "text":
                    // Text refinement representation
                    imageArea.append("rect")
                        .attr("x", stageWidth/2 - 60) // Wider text box
                        .attr("y", 30)
                        .attr("width", 120) // Wider text box
                        .attr("height", 80)
                        .attr("fill", "#f0e6ff")
                        .attr("stroke", "#8C50FF");
                    
                    for (let i = 0; i < 4; i++) {
                        imageArea.append("line")
                            .attr("x1", stageWidth/2 - 50)
                            .attr("y1", 45 + i*15)
                            .attr("x2", stageWidth/2 + 50)
                            .attr("y2", 45 + i*15)
                            .attr("stroke", "#8C50FF")
                            .attr("stroke-width", i === 0 ? 2 : 1);
                    }
                    
                    // Add edit icon using Unicode character for pencil
                    imageArea.append("text")
                        .attr("x", stageWidth/2)
                        .attr("y", 120)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "16px")
                        .attr("fill", "#8C50FF")
                        .text("✏️"); // Pencil emoji
                    break;
                    
                case "improved":
                    // More refined design - centered properly
                    imageArea.append("rect")
                        .attr("x", stageWidth/2 - 60) // Centered and wider
                        .attr("y", 20)
                        .attr("width", 120) // Wider
                        .attr("height", 70)
                        .attr("fill", "#e6f7e6")
                        .attr("stroke", "#8C50FF");
                    
                    // Windows
                    for (let i = 0; i < 3; i++) {
                        imageArea.append("rect")
                            .attr("x", stageWidth/2 - 50 + i*35) // Better spacing
                            .attr("y", 30)
                            .attr("width", 25) // Wider windows
                            .attr("height", 30)
                            .attr("fill", "#d9c6ff");
                    }
                    
                    // Logo - properly centered
                    imageArea.append("path")
                        .attr("d", `M${stageWidth/2},110 Q${stageWidth/2-20},90 ${stageWidth/2},70 Q${stageWidth/2+20},90 ${stageWidth/2},110`)
                        .attr("fill", "#8C50FF");
                    break;
                    
                case "final":
                    // Final polished design - properly centered
                    imageArea.append("rect")
                        .attr("x", stageWidth/2 - 70) // Centered and wider
                        .attr("y", 20)
                        .attr("width", 140) // Wider
                        .attr("height", 80)
                        .attr("fill", "#e6f7e6")
                        .attr("stroke", "#8C50FF")
                        .attr("stroke-width", 2);
                    
                    // Windows - better spacing
                    for (let i = 0; i < 4; i++) {
                        imageArea.append("rect")
                            .attr("x", stageWidth/2 - 60 + i*30) // Better spacing
                            .attr("y", 30)
                            .attr("width", 20)
                            .attr("height", 30)
                            .attr("fill", "#d9c6ff");
                    }
                    
                    // Logo - properly centered
                    imageArea.append("circle")
                        .attr("cx", stageWidth/2)
                        .attr("cy", 110)
                        .attr("r", 15)
                        .attr("fill", "#8C50FF");
                    
                    // Star for quality
                    imageArea.append("text")
                        .attr("x", stageWidth/2 + 60)
                        .attr("y", 30)
                        .attr("font-size", "16px")
                        .attr("fill", "#8C50FF")
                        .text("★"); // Unicode star character
                    break;
            }
        });

        // Add connecting arrows
        // Forward arrows
        for (let i = 0; i < 4; i++) {
            const startX = (i + 1) * stageWidth + i * stageSpacing;
            const endX = startX + stageSpacing;
            const centerY = 160;
            
            svg.append("path")
                .attr("d", `M${startX},${centerY} L${endX},${centerY}`)
                .attr("stroke", "#8C50FF")
                .attr("stroke-width", 2)
                .attr("marker-end", "url(#arrow)");
        }
        
        // Add arrow marker definition
        svg.append("defs").append("marker")
            .attr("id", "arrow")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 8)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "#8C50FF");
            
        // Add feedback loops
        // Loop from Stage 4 back to Stage 3
        const loop1StartX = 4 * stageWidth + 3 * stageSpacing - 20;
        const loop1EndX = 2 * stageWidth + 2 * stageSpacing + 20;
        svg.append("path")
            .attr("d", `M${loop1StartX},${stageHeight + 30} C${(loop1StartX + loop1EndX)/2},${stageHeight + 60} ${(loop1StartX + loop1EndX)/2},${stageHeight + 60} ${loop1EndX},${stageHeight + 30}`)
            .attr("stroke", "#8C50FF")
            .attr("stroke-width", 2)
            .attr("fill", "none")
            .attr("stroke-dasharray", "5,5")
            .attr("marker-end", "url(#arrow)");
            
        // Loop from Stage 2 back to Stage 1
        const loop2StartX = 1 * stageWidth + 0 * stageSpacing + 20;
        const loop2EndX = 0 * stageWidth + 0 * stageSpacing + stageWidth - 20;
        svg.append("path")
            .attr("d", `M${loop2StartX},${stageHeight + 20} C${(loop2StartX + loop2EndX)/2},${stageHeight + 50} ${(loop2StartX + loop2EndX)/2},${stageHeight + 50} ${loop2EndX},${stageHeight + 20}`)
            .attr("stroke", "#8C50FF")
            .attr("stroke-width", 2)
            .attr("fill", "none")
            .attr("stroke-dasharray", "5,5")
            .attr("marker-end", "url(#arrow)");
            
        // Add loop labels with improved formatting
        svg.append("text")
            .attr("x", (loop1StartX + loop1EndX)/2)
            .attr("y", stageHeight + 50)
            .attr("text-anchor", "middle")
            .attr("fill", "#8C50FF")
            .attr("font-size", "12px") // Increased font size
            .attr("font-weight", "bold") // Added bold
            .text("Iterative Refinement"); // No letter spacing issues
            
        svg.append("text")
            .attr("x", (loop2StartX + loop2EndX)/2)
            .attr("y", stageHeight + 40)
            .attr("text-anchor", "middle")
            .attr("fill", "#8C50FF")
            .attr("font-size", "12px") // Increased font size
            .attr("font-weight", "bold") // Added bold
            .text("Restart if needed");
    </script>
</body>
</html>